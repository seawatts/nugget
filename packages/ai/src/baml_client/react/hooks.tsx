/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

'use client'

import type { BamlErrors } from '@boundaryml/baml/errors'
import { toBamlError } from '@boundaryml/baml/errors'
import { useCallback, useMemo, useReducer, useTransition } from 'react'
import * as Actions from './server'
import * as StreamingActions from './server_streaming'
import type { StreamingServerTypes } from './server_streaming_types'

/**
 * Type representing a BAML stream response.
 *
 * @template PartialType The type of the partial response.
 * @template FinalType The type of the final response.
 */
type BamlStreamResponse<PartialType, FinalType> = {
  partial?: PartialType
  final?: FinalType
  error?: BamlErrors
}

/**
 * A server action that returns either a ReadableStream of Uint8Array or a final output.
 */
export type ServerAction<Input = any, Output = any> = (
  ...args: Input extends any[] ? Input : [Input]
) => Promise<Output> | ReadableStream<Uint8Array>

/**
 * Type representing all function names except 'stream' and 'stream_types'
 */
export type FunctionNames = keyof typeof Actions

/**
 * Helper type to derive the partial return type for an action.
 */
type StreamDataType<FunctionName extends FunctionNames> = StreamingServerTypes[FunctionName]

/**
 * Helper type to derive the final return type for an action.
 */
type FinalDataType<FunctionName extends FunctionNames> = (typeof Actions)[FunctionName] extends (...args: any) => any
  ? Awaited<ReturnType<(typeof Actions)[FunctionName]>>
  : never

/**
 * Configuration options for BAML React hooks.
 */
export type HookInput<FunctionName extends FunctionNames = FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  stream?: Options['stream']
  onStreamData?: Options['stream'] extends false ? never : (response?: StreamDataType<FunctionName>) => void
  onFinalData?: (response?: FinalDataType<FunctionName>) => void
  onData?: (response?: Options['stream'] extends false ? FinalDataType<FunctionName> : FinalDataType<FunctionName> | StreamDataType<FunctionName>) => void
  onError?: (error: BamlErrors) => void
}

export type NonStreamingHookStatus = 'idle' | 'pending' | 'success' | 'error'
export type StreamingHookStatus = NonStreamingHookStatus | 'streaming'

export type HookStatus<Options extends { stream?: boolean } = { stream?: true }> = Options['stream'] extends false
  ? NonStreamingHookStatus
  : StreamingHookStatus

/**
 * Return type for BAML React hooks.
 */
export type HookOutput<FunctionName extends FunctionNames = FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  data?: Options['stream'] extends false ? FinalDataType<FunctionName> : FinalDataType<FunctionName> | StreamDataType<FunctionName>
  finalData?: FinalDataType<FunctionName>
  streamData?: Options['stream'] extends false ? never : StreamDataType<FunctionName>
  isLoading: boolean
  isPending: boolean
  isStreaming: Options['stream'] extends false ? never : boolean
  isSuccess: boolean
  isError: boolean
  error?: BamlErrors
  status: HookStatus<Options>
  mutate: (
    ...args: Parameters<(typeof Actions)[FunctionName]>
  ) => Options['stream'] extends false ? Promise<FinalDataType<FunctionName>> : Promise<ReadableStream<Uint8Array>>
  reset: () => void
}

export type HookData<FunctionName extends FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = NonNullable<HookOutput<FunctionName, Options>['data']>;

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template FunctionName - The name of the BAML function.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<FunctionName extends FunctionNames>(
  props: HookInput<FunctionName, { stream?: boolean }>,
): props is HookInput<FunctionName, { stream?: true }> {
  return props.stream !== false
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean
  isStreaming: boolean
  error?: BamlErrors
  finalData?: TFinal
  streamData?: TPartial
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: BamlErrors }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' }

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>,
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        isStreaming: false,
        finalData: undefined,
        streamData: undefined,
      }
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        isStreaming: false,
        error: action.payload,
      }
    case 'SET_PARTIAL':
      return {
        ...state,
        isStreaming: true,
        streamData: action.payload,
      }
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        isStreaming: false,
        finalData: action.payload,
      }
    case 'RESET':
      return {
        isSuccess: false,
        isStreaming: false,
        error: undefined,
        finalData: undefined,
        streamData: undefined,
      }
    default:
      return state
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `streamData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isLoading`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isLoading, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream: false }>,
): HookOutput<FunctionName, { stream: false }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props?: HookInput<FunctionName, { stream?: true }>,
): HookOutput<FunctionName, { stream: true }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream?: boolean }> = {},
): HookOutput<FunctionName, { stream: true }> | HookOutput<FunctionName, { stream: false }> {
  const { onFinalData, onError } = props
  const [isLoading, startTransition] = useTransition()

  const [state, dispatch] = useReducer(hookReducer<StreamDataType<FunctionName>, FinalDataType<FunctionName>>, {
    isSuccess: false,
    error: undefined,
    finalData: undefined,
    isStreaming: false,
    streamData: undefined,
  })

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' })
      try {
        let response: Awaited<ReturnType<ServerAction>>
        startTransition(async () => {
          // Transform any BamlImage or BamlAudio inputs to their JSON representation
          const transformedInput = input.map(arg => {
            // Check if the argument is an instance of BamlImage or BamlAudio
            // We check the constructor name since the actual classes might be proxied in browser environments
            if (arg && typeof arg === 'object' &&
                (arg.constructor.name === 'BamlImage' || arg.constructor.name === 'BamlAudio')) {
              return arg.toJSON();
            }
            return arg;
          });

          response = await action(...transformedInput)

          if (isStreamingProps(props) && response instanceof ReadableStream) {
            const reader = response.getReader()
            const decoder = new TextDecoder()
            try {
              while (true) {
                const { value, done } = await reader.read()
                if (done) break
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim()
                  try {
                    const parsed: BamlStreamResponse<
                      StreamDataType<FunctionName>,
                      FinalDataType<FunctionName>
                    > = JSON.parse(chunk)
                    if (parsed.error) {
                       if (parsed.error instanceof Error) {
                        throw parsed.error
                      }

                      const parsedError = JSON.parse(parsed.error)
                      const finalError = toBamlError(parsedError)
                      throw finalError
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({ type: 'SET_PARTIAL', payload: parsed.partial })
                      if (isStreamingProps(props)) {
                        props.onStreamData?.(parsed.partial)
                      }
                      props.onData?.(parsed.partial)
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final })
                      onFinalData?.(parsed.final)
                      props.onData?.(parsed.final)
                      return
                    }
                  } catch (err: unknown) {
                    dispatch({
                      type: 'SET_ERROR',
                      payload: err as BamlErrors,
                    })
                    onError?.(err as BamlErrors)
                    break
                  }
                }
              }
            } finally {
              reader.releaseLock()
            }
            return
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response })
          onFinalData?.(response)
        })
        return response
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as BamlErrors })
        onError?.(error_ as BamlErrors)
        throw error_
      }
    },
    [action, onFinalData, onError, props],
  )

  const status = useMemo<HookStatus<{ stream: typeof props.stream }>>(() => {
    if (state.error) return 'error'
    if (state.isSuccess) return 'success'
    if (state.isStreaming) return 'streaming'
    if (isLoading) return 'pending'
    return 'idle'
  }, [isLoading, state.error, state.isSuccess, state.isStreaming])

  let data:
		| FinalDataType<FunctionName>
		| StreamDataType<FunctionName>
		| undefined = state.finalData;
  if (state.isStreaming) data = state.streamData

  const result = {
    data,
    finalData: state.finalData,
    error: state.error,
    isError: status === 'error',
    isSuccess: status === 'success',
    isStreaming: status === 'streaming',
    isPending: status === 'pending',
    isLoading: status === 'pending' || status === 'streaming',
    mutate,
    status,
    reset: () => dispatch({ type: 'RESET' }),
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>

  return {
    ...result,
    streamData: isStreamingProps(props) ? state.streamData : undefined,
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>
}
/**
 * A specialized hook for the AppointmentNudge BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - type: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.AppointmentNudgeOutput
 * - **Streaming Partial:** AppointmentNudgeOutput
 * - **Streaming Final:** types.AppointmentNudgeOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAppointmentNudge({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAppointmentNudge({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAppointmentNudge(props: HookInput<'AppointmentNudge', { stream: false }>): HookOutput<'AppointmentNudge', { stream: false }>
export function useAppointmentNudge(props?: HookInput<'AppointmentNudge', { stream?: true }>): HookOutput<'AppointmentNudge', { stream: true }>
export function useAppointmentNudge(
  props: HookInput<'AppointmentNudge', { stream?: boolean }> = {},
): HookOutput<'AppointmentNudge', { stream: true }> | HookOutput<'AppointmentNudge', { stream: false }> {
  let action: ServerAction = Actions.AppointmentNudge;
  if (isStreamingProps(props)) {
    action = StreamingActions.AppointmentNudge;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'AppointmentNudge', { stream: false }>)
  }
}
/**
 * A specialized hook for the BabyAssistantChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - conversationHistory: types.ChatMessage[]
 *
 * - babyContext: types.BabyContext
 *
 * - userQuestion: string
 *
 * - systemPrompt (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.BabyAssistantChatOutput
 * - **Streaming Partial:** BabyAssistantChatOutput
 * - **Streaming Final:** types.BabyAssistantChatOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useBabyAssistantChat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useBabyAssistantChat({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBabyAssistantChat(props: HookInput<'BabyAssistantChat', { stream: false }>): HookOutput<'BabyAssistantChat', { stream: false }>
export function useBabyAssistantChat(props?: HookInput<'BabyAssistantChat', { stream?: true }>): HookOutput<'BabyAssistantChat', { stream: true }>
export function useBabyAssistantChat(
  props: HookInput<'BabyAssistantChat', { stream?: boolean }> = {},
): HookOutput<'BabyAssistantChat', { stream: true }> | HookOutput<'BabyAssistantChat', { stream: false }> {
  let action: ServerAction = Actions.BabyAssistantChat;
  if (isStreamingProps(props)) {
    action = StreamingActions.BabyAssistantChat;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'BabyAssistantChat', { stream: false }>)
  }
}
/**
 * A specialized hook for the BabyVisitExplainer BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - ageWeeks: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.BabyVisitExplainerOutput
 * - **Streaming Partial:** BabyVisitExplainerOutput
 * - **Streaming Final:** types.BabyVisitExplainerOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useBabyVisitExplainer({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useBabyVisitExplainer({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBabyVisitExplainer(props: HookInput<'BabyVisitExplainer', { stream: false }>): HookOutput<'BabyVisitExplainer', { stream: false }>
export function useBabyVisitExplainer(props?: HookInput<'BabyVisitExplainer', { stream?: true }>): HookOutput<'BabyVisitExplainer', { stream: true }>
export function useBabyVisitExplainer(
  props: HookInput<'BabyVisitExplainer', { stream?: boolean }> = {},
): HookOutput<'BabyVisitExplainer', { stream: true }> | HookOutput<'BabyVisitExplainer', { stream: false }> {
  let action: ServerAction = Actions.BabyVisitExplainer;
  if (isStreamingProps(props)) {
    action = StreamingActions.BabyVisitExplainer;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'BabyVisitExplainer', { stream: false }>)
  }
}
/**
 * A specialized hook for the BirthPlanHeadline BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - mode: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.BirthPlanHeadlineOutput
 * - **Streaming Partial:** BirthPlanHeadlineOutput
 * - **Streaming Final:** types.BirthPlanHeadlineOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useBirthPlanHeadline({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useBirthPlanHeadline({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBirthPlanHeadline(props: HookInput<'BirthPlanHeadline', { stream: false }>): HookOutput<'BirthPlanHeadline', { stream: false }>
export function useBirthPlanHeadline(props?: HookInput<'BirthPlanHeadline', { stream?: true }>): HookOutput<'BirthPlanHeadline', { stream: true }>
export function useBirthPlanHeadline(
  props: HookInput<'BirthPlanHeadline', { stream?: boolean }> = {},
): HookOutput<'BirthPlanHeadline', { stream: true }> | HookOutput<'BirthPlanHeadline', { stream: false }> {
  let action: ServerAction = Actions.BirthPlanHeadline;
  if (isStreamingProps(props)) {
    action = StreamingActions.BirthPlanHeadline;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'BirthPlanHeadline', { stream: false }>)
  }
}
/**
 * A specialized hook for the DailyCheckInQuestions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - ppDay: number
 *
 * - parentRole: string
 *
 * - parentSleepHours (optional): number | null
 *
 * - ageInDays: number
 *
 * - ageInWeeks: number
 *
 * - firstPregnancy: boolean
 *
 * - avgFeedingsPerDay (optional): number | null
 *
 * - avgSleepHoursPerDay (optional): number | null
 *
 * - avgDiaperChangesPerDay (optional): number | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.DailyCheckInQuestionsOutput
 * - **Streaming Partial:** DailyCheckInQuestionsOutput
 * - **Streaming Final:** types.DailyCheckInQuestionsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useDailyCheckInQuestions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useDailyCheckInQuestions({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDailyCheckInQuestions(props: HookInput<'DailyCheckInQuestions', { stream: false }>): HookOutput<'DailyCheckInQuestions', { stream: false }>
export function useDailyCheckInQuestions(props?: HookInput<'DailyCheckInQuestions', { stream?: true }>): HookOutput<'DailyCheckInQuestions', { stream: true }>
export function useDailyCheckInQuestions(
  props: HookInput<'DailyCheckInQuestions', { stream?: boolean }> = {},
): HookOutput<'DailyCheckInQuestions', { stream: true }> | HookOutput<'DailyCheckInQuestions', { stream: false }> {
  let action: ServerAction = Actions.DailyCheckInQuestions;
  if (isStreamingProps(props)) {
    action = StreamingActions.DailyCheckInQuestions;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'DailyCheckInQuestions', { stream: false }>)
  }
}
/**
 * A specialized hook for the DailyLearningPlanner BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - ageInWeeks: number
 *
 * - firstTimeParent: boolean
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - height (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - totalSleepHours24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - avgFeedingsPerDay (optional): number | null
 *
 * - avgSleepHoursPerDay (optional): number | null
 *
 * - avgDiaperChangesPerDay (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - recentlyCoveredTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - activitySummary (optional): string | null
 *
 * - parentWellness (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.DailyLearningPlan
 * - **Streaming Partial:** DailyLearningPlan
 * - **Streaming Final:** types.DailyLearningPlan
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useDailyLearningPlanner({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useDailyLearningPlanner({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDailyLearningPlanner(props: HookInput<'DailyLearningPlanner', { stream: false }>): HookOutput<'DailyLearningPlanner', { stream: false }>
export function useDailyLearningPlanner(props?: HookInput<'DailyLearningPlanner', { stream?: true }>): HookOutput<'DailyLearningPlanner', { stream: true }>
export function useDailyLearningPlanner(
  props: HookInput<'DailyLearningPlanner', { stream?: boolean }> = {},
): HookOutput<'DailyLearningPlanner', { stream: true }> | HookOutput<'DailyLearningPlanner', { stream: false }> {
  let action: ServerAction = Actions.DailyLearningPlanner;
  if (isStreamingProps(props)) {
    action = StreamingActions.DailyLearningPlanner;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'DailyLearningPlanner', { stream: false }>)
  }
}
/**
 * A specialized hook for the DailyWellnessQuestion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - babyAgeInDays: number
 *
 * - babyAgeInWeeks: number
 *
 * - feedingCount24h (optional): number | null
 *
 * - sleepHours24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - previousResponses (optional): string | null
 *
 * - currentStreak (optional): number | null
 *
 * - weeklyCompletionCount (optional): number | null
 *
 * - daysSinceLastResponse (optional): number | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.DailyWellnessQuestionOutput
 * - **Streaming Partial:** DailyWellnessQuestionOutput
 * - **Streaming Final:** types.DailyWellnessQuestionOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useDailyWellnessQuestion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useDailyWellnessQuestion({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDailyWellnessQuestion(props: HookInput<'DailyWellnessQuestion', { stream: false }>): HookOutput<'DailyWellnessQuestion', { stream: false }>
export function useDailyWellnessQuestion(props?: HookInput<'DailyWellnessQuestion', { stream?: true }>): HookOutput<'DailyWellnessQuestion', { stream: true }>
export function useDailyWellnessQuestion(
  props: HookInput<'DailyWellnessQuestion', { stream?: boolean }> = {},
): HookOutput<'DailyWellnessQuestion', { stream: true }> | HookOutput<'DailyWellnessQuestion', { stream: false }> {
  let action: ServerAction = Actions.DailyWellnessQuestion;
  if (isStreamingProps(props)) {
    action = StreamingActions.DailyWellnessQuestion;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'DailyWellnessQuestion', { stream: false }>)
  }
}
/**
 * A specialized hook for the EnhanceMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - milestoneTitle: string
 *
 * - milestoneDescription: string
 *
 * - milestoneType: string
 *
 * - ageLabel: string
 *
 * - babyName (optional): string | null
 *
 * - babySex (optional): string | null
 *
 * - ageInDays (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - activitySummary (optional): string | null
 *
 * - parentWellness (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useEnhanceMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useEnhanceMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useEnhanceMilestone(props: HookInput<'EnhanceMilestone', { stream: false }>): HookOutput<'EnhanceMilestone', { stream: false }>
export function useEnhanceMilestone(props?: HookInput<'EnhanceMilestone', { stream?: true }>): HookOutput<'EnhanceMilestone', { stream: true }>
export function useEnhanceMilestone(
  props: HookInput<'EnhanceMilestone', { stream?: boolean }> = {},
): HookOutput<'EnhanceMilestone', { stream: true }> | HookOutput<'EnhanceMilestone', { stream: false }> {
  let action: ServerAction = Actions.EnhanceMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.EnhanceMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'EnhanceMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the FirstWeekMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useFirstWeekMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useFirstWeekMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFirstWeekMilestone(props: HookInput<'FirstWeekMilestone', { stream: false }>): HookOutput<'FirstWeekMilestone', { stream: false }>
export function useFirstWeekMilestone(props?: HookInput<'FirstWeekMilestone', { stream?: true }>): HookOutput<'FirstWeekMilestone', { stream: true }>
export function useFirstWeekMilestone(
  props: HookInput<'FirstWeekMilestone', { stream?: boolean }> = {},
): HookOutput<'FirstWeekMilestone', { stream: true }> | HookOutput<'FirstWeekMilestone', { stream: false }> {
  let action: ServerAction = Actions.FirstWeekMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.FirstWeekMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'FirstWeekMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateCelebrationSummary BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - ageInDays: number
 *
 * - celebrationType: string
 *
 * - celebrationTitle: string
 *
 * - statistics: types.CelebrationStatistics
 *
 * - recentMilestones (optional): string | null
 *
 * - recentActivities (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.CelebrationSummaryOutput
 * - **Streaming Partial:** CelebrationSummaryOutput
 * - **Streaming Final:** types.CelebrationSummaryOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateCelebrationSummary({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateCelebrationSummary({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateCelebrationSummary(props: HookInput<'GenerateCelebrationSummary', { stream: false }>): HookOutput<'GenerateCelebrationSummary', { stream: false }>
export function useGenerateCelebrationSummary(props?: HookInput<'GenerateCelebrationSummary', { stream?: true }>): HookOutput<'GenerateCelebrationSummary', { stream: true }>
export function useGenerateCelebrationSummary(
  props: HookInput<'GenerateCelebrationSummary', { stream?: boolean }> = {},
): HookOutput<'GenerateCelebrationSummary', { stream: true }> | HookOutput<'GenerateCelebrationSummary', { stream: false }> {
  let action: ServerAction = Actions.GenerateCelebrationSummary;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateCelebrationSummary;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateCelebrationSummary', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateChatTitle BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - firstUserMessage: string
 *
 * - firstAssistantResponse: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.ChatTitleOutput
 * - **Streaming Partial:** ChatTitleOutput
 * - **Streaming Final:** types.ChatTitleOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateChatTitle({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateChatTitle({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateChatTitle(props: HookInput<'GenerateChatTitle', { stream: false }>): HookOutput<'GenerateChatTitle', { stream: false }>
export function useGenerateChatTitle(props?: HookInput<'GenerateChatTitle', { stream?: true }>): HookOutput<'GenerateChatTitle', { stream: true }>
export function useGenerateChatTitle(
  props: HookInput<'GenerateChatTitle', { stream?: boolean }> = {},
): HookOutput<'GenerateChatTitle', { stream: true }> | HookOutput<'GenerateChatTitle', { stream: false }> {
  let action: ServerAction = Actions.GenerateChatTitle;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateChatTitle;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateChatTitle', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateContextualMilestones BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - ageInDays: number
 *
 * - ageInWeeks: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - height (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - totalSleepHours24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - avgFeedingsPerDay (optional): number | null
 *
 * - avgSleepHoursPerDay (optional): number | null
 *
 * - avgDiaperChangesPerDay (optional): number | null
 *
 * - recentDiaperColors (optional): string | null
 *
 * - hasTummyTimeActivity (optional): boolean | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.ContextualMilestonesOutput
 * - **Streaming Partial:** ContextualMilestonesOutput
 * - **Streaming Final:** types.ContextualMilestonesOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateContextualMilestones({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateContextualMilestones({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateContextualMilestones(props: HookInput<'GenerateContextualMilestones', { stream: false }>): HookOutput<'GenerateContextualMilestones', { stream: false }>
export function useGenerateContextualMilestones(props?: HookInput<'GenerateContextualMilestones', { stream?: true }>): HookOutput<'GenerateContextualMilestones', { stream: true }>
export function useGenerateContextualMilestones(
  props: HookInput<'GenerateContextualMilestones', { stream?: boolean }> = {},
): HookOutput<'GenerateContextualMilestones', { stream: true }> | HookOutput<'GenerateContextualMilestones', { stream: false }> {
  let action: ServerAction = Actions.GenerateContextualMilestones;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateContextualMilestones;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateContextualMilestones', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateDoctorQuestions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - dayCount: number
 *
 * - totalFeedings: number
 *
 * - averageFeedingsPerDay: number
 *
 * - totalFeedingMl: number
 *
 * - averageMlPerFeeding: number
 *
 * - totalSleeps: number
 *
 * - totalSleepHours: number
 *
 * - averageSleepHoursPerDay: number
 *
 * - longestSleepHours: number
 *
 * - totalDiapers: number
 *
 * - averageDiapersPerDay: number
 *
 * - wetDiapers: number
 *
 * - dirtyDiapers: number
 *
 * - bothDiapers: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.DoctorQuestionsOutput
 * - **Streaming Partial:** DoctorQuestionsOutput
 * - **Streaming Final:** types.DoctorQuestionsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateDoctorQuestions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateDoctorQuestions({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateDoctorQuestions(props: HookInput<'GenerateDoctorQuestions', { stream: false }>): HookOutput<'GenerateDoctorQuestions', { stream: false }>
export function useGenerateDoctorQuestions(props?: HookInput<'GenerateDoctorQuestions', { stream?: true }>): HookOutput<'GenerateDoctorQuestions', { stream: true }>
export function useGenerateDoctorQuestions(
  props: HookInput<'GenerateDoctorQuestions', { stream?: boolean }> = {},
): HookOutput<'GenerateDoctorQuestions', { stream: true }> | HookOutput<'GenerateDoctorQuestions', { stream: false }> {
  let action: ServerAction = Actions.GenerateDoctorQuestions;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateDoctorQuestions;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateDoctorQuestions', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_FirstWeek BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_FirstWeek({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_FirstWeek({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_FirstWeek(props: HookInput<'GenerateLearningTip_FirstWeek', { stream: false }>): HookOutput<'GenerateLearningTip_FirstWeek', { stream: false }>
export function useGenerateLearningTip_FirstWeek(props?: HookInput<'GenerateLearningTip_FirstWeek', { stream?: true }>): HookOutput<'GenerateLearningTip_FirstWeek', { stream: true }>
export function useGenerateLearningTip_FirstWeek(
  props: HookInput<'GenerateLearningTip_FirstWeek', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_FirstWeek', { stream: true }> | HookOutput<'GenerateLearningTip_FirstWeek', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_FirstWeek;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_FirstWeek;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_FirstWeek', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_ImmediatePostbirth BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_ImmediatePostbirth({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_ImmediatePostbirth({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_ImmediatePostbirth(props: HookInput<'GenerateLearningTip_ImmediatePostbirth', { stream: false }>): HookOutput<'GenerateLearningTip_ImmediatePostbirth', { stream: false }>
export function useGenerateLearningTip_ImmediatePostbirth(props?: HookInput<'GenerateLearningTip_ImmediatePostbirth', { stream?: true }>): HookOutput<'GenerateLearningTip_ImmediatePostbirth', { stream: true }>
export function useGenerateLearningTip_ImmediatePostbirth(
  props: HookInput<'GenerateLearningTip_ImmediatePostbirth', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_ImmediatePostbirth', { stream: true }> | HookOutput<'GenerateLearningTip_ImmediatePostbirth', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_ImmediatePostbirth;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_ImmediatePostbirth;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_ImmediatePostbirth', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_MonthOne BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_MonthOne({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_MonthOne({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_MonthOne(props: HookInput<'GenerateLearningTip_MonthOne', { stream: false }>): HookOutput<'GenerateLearningTip_MonthOne', { stream: false }>
export function useGenerateLearningTip_MonthOne(props?: HookInput<'GenerateLearningTip_MonthOne', { stream?: true }>): HookOutput<'GenerateLearningTip_MonthOne', { stream: true }>
export function useGenerateLearningTip_MonthOne(
  props: HookInput<'GenerateLearningTip_MonthOne', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_MonthOne', { stream: true }> | HookOutput<'GenerateLearningTip_MonthOne', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_MonthOne;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_MonthOne;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_MonthOne', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_MonthThreeFour BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_MonthThreeFour({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_MonthThreeFour({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_MonthThreeFour(props: HookInput<'GenerateLearningTip_MonthThreeFour', { stream: false }>): HookOutput<'GenerateLearningTip_MonthThreeFour', { stream: false }>
export function useGenerateLearningTip_MonthThreeFour(props?: HookInput<'GenerateLearningTip_MonthThreeFour', { stream?: true }>): HookOutput<'GenerateLearningTip_MonthThreeFour', { stream: true }>
export function useGenerateLearningTip_MonthThreeFour(
  props: HookInput<'GenerateLearningTip_MonthThreeFour', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_MonthThreeFour', { stream: true }> | HookOutput<'GenerateLearningTip_MonthThreeFour', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_MonthThreeFour;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_MonthThreeFour;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_MonthThreeFour', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_MonthTwo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_MonthTwo({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_MonthTwo({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_MonthTwo(props: HookInput<'GenerateLearningTip_MonthTwo', { stream: false }>): HookOutput<'GenerateLearningTip_MonthTwo', { stream: false }>
export function useGenerateLearningTip_MonthTwo(props?: HookInput<'GenerateLearningTip_MonthTwo', { stream?: true }>): HookOutput<'GenerateLearningTip_MonthTwo', { stream: true }>
export function useGenerateLearningTip_MonthTwo(
  props: HookInput<'GenerateLearningTip_MonthTwo', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_MonthTwo', { stream: true }> | HookOutput<'GenerateLearningTip_MonthTwo', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_MonthTwo;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_MonthTwo;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_MonthTwo', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_SecondWeek BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_SecondWeek({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_SecondWeek({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_SecondWeek(props: HookInput<'GenerateLearningTip_SecondWeek', { stream: false }>): HookOutput<'GenerateLearningTip_SecondWeek', { stream: false }>
export function useGenerateLearningTip_SecondWeek(props?: HookInput<'GenerateLearningTip_SecondWeek', { stream?: true }>): HookOutput<'GenerateLearningTip_SecondWeek', { stream: true }>
export function useGenerateLearningTip_SecondWeek(
  props: HookInput<'GenerateLearningTip_SecondWeek', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_SecondWeek', { stream: true }> | HookOutput<'GenerateLearningTip_SecondWeek', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_SecondWeek;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_SecondWeek;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_SecondWeek', { stream: false }>)
  }
}
/**
 * A specialized hook for the GenerateLearningTip_ThirdWeek BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - category: string
 *
 * - title: string
 *
 * - subtitle: string
 *
 * - relevance: string
 *
 * - recommendYesNo: boolean
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.LearningTip
 * - **Streaming Partial:** LearningTip
 * - **Streaming Final:** types.LearningTip
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateLearningTip_ThirdWeek({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateLearningTip_ThirdWeek({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateLearningTip_ThirdWeek(props: HookInput<'GenerateLearningTip_ThirdWeek', { stream: false }>): HookOutput<'GenerateLearningTip_ThirdWeek', { stream: false }>
export function useGenerateLearningTip_ThirdWeek(props?: HookInput<'GenerateLearningTip_ThirdWeek', { stream?: true }>): HookOutput<'GenerateLearningTip_ThirdWeek', { stream: true }>
export function useGenerateLearningTip_ThirdWeek(
  props: HookInput<'GenerateLearningTip_ThirdWeek', { stream?: boolean }> = {},
): HookOutput<'GenerateLearningTip_ThirdWeek', { stream: true }> | HookOutput<'GenerateLearningTip_ThirdWeek', { stream: false }> {
  let action: ServerAction = Actions.GenerateLearningTip_ThirdWeek;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateLearningTip_ThirdWeek;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'GenerateLearningTip_ThirdWeek', { stream: false }>)
  }
}
/**
 * A specialized hook for the HospitalPackAdvice BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - progress: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.HospitalPackAdviceOutput
 * - **Streaming Partial:** HospitalPackAdviceOutput
 * - **Streaming Final:** types.HospitalPackAdviceOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useHospitalPackAdvice({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useHospitalPackAdvice({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useHospitalPackAdvice(props: HookInput<'HospitalPackAdvice', { stream: false }>): HookOutput<'HospitalPackAdvice', { stream: false }>
export function useHospitalPackAdvice(props?: HookInput<'HospitalPackAdvice', { stream?: true }>): HookOutput<'HospitalPackAdvice', { stream: true }>
export function useHospitalPackAdvice(
  props: HookInput<'HospitalPackAdvice', { stream?: boolean }> = {},
): HookOutput<'HospitalPackAdvice', { stream: true }> | HookOutput<'HospitalPackAdvice', { stream: false }> {
  let action: ServerAction = Actions.HospitalPackAdvice;
  if (isStreamingProps(props)) {
    action = StreamingActions.HospitalPackAdvice;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'HospitalPackAdvice', { stream: false }>)
  }
}
/**
 * A specialized hook for the ImmediatePostbirthMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useImmediatePostbirthMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useImmediatePostbirthMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useImmediatePostbirthMilestone(props: HookInput<'ImmediatePostbirthMilestone', { stream: false }>): HookOutput<'ImmediatePostbirthMilestone', { stream: false }>
export function useImmediatePostbirthMilestone(props?: HookInput<'ImmediatePostbirthMilestone', { stream?: true }>): HookOutput<'ImmediatePostbirthMilestone', { stream: true }>
export function useImmediatePostbirthMilestone(
  props: HookInput<'ImmediatePostbirthMilestone', { stream?: boolean }> = {},
): HookOutput<'ImmediatePostbirthMilestone', { stream: true }> | HookOutput<'ImmediatePostbirthMilestone', { stream: false }> {
  let action: ServerAction = Actions.ImmediatePostbirthMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.ImmediatePostbirthMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'ImmediatePostbirthMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the MilestoneExplanation BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - milestoneTitle: string
 *
 * - milestoneType: string
 *
 * - babyName: string
 *
 * - ageInDays: number
 *
 * - ageInWeeks: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneExplanationOutput
 * - **Streaming Partial:** MilestoneExplanationOutput
 * - **Streaming Final:** types.MilestoneExplanationOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMilestoneExplanation({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMilestoneExplanation({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMilestoneExplanation(props: HookInput<'MilestoneExplanation', { stream: false }>): HookOutput<'MilestoneExplanation', { stream: false }>
export function useMilestoneExplanation(props?: HookInput<'MilestoneExplanation', { stream?: true }>): HookOutput<'MilestoneExplanation', { stream: true }>
export function useMilestoneExplanation(
  props: HookInput<'MilestoneExplanation', { stream?: boolean }> = {},
): HookOutput<'MilestoneExplanation', { stream: true }> | HookOutput<'MilestoneExplanation', { stream: false }> {
  let action: ServerAction = Actions.MilestoneExplanation;
  if (isStreamingProps(props)) {
    action = StreamingActions.MilestoneExplanation;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'MilestoneExplanation', { stream: false }>)
  }
}
/**
 * A specialized hook for the MilestonePlanner BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - babySex (optional): string | null
 *
 * - ageInDays: number
 *
 * - ageInWeeks: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - height (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - avgFeedingInterval (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - totalSleepHours24h (optional): number | null
 *
 * - diaperCount24h (optional): number | null
 *
 * - avgFeedingsPerDay (optional): number | null
 *
 * - avgSleepHoursPerDay (optional): number | null
 *
 * - avgDiaperChangesPerDay (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - recentlySuggestedMilestones (optional): string | null
 *
 * - activitySummary (optional): string | null
 *
 * - hasTummyTimeActivity (optional): boolean | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestonePlan
 * - **Streaming Partial:** MilestonePlan
 * - **Streaming Final:** types.MilestonePlan
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMilestonePlanner({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMilestonePlanner({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMilestonePlanner(props: HookInput<'MilestonePlanner', { stream: false }>): HookOutput<'MilestonePlanner', { stream: false }>
export function useMilestonePlanner(props?: HookInput<'MilestonePlanner', { stream?: true }>): HookOutput<'MilestonePlanner', { stream: true }>
export function useMilestonePlanner(
  props: HookInput<'MilestonePlanner', { stream?: boolean }> = {},
): HookOutput<'MilestonePlanner', { stream: true }> | HookOutput<'MilestonePlanner', { stream: false }> {
  let action: ServerAction = Actions.MilestonePlanner;
  if (isStreamingProps(props)) {
    action = StreamingActions.MilestonePlanner;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'MilestonePlanner', { stream: false }>)
  }
}
/**
 * A specialized hook for the MonthOneMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMonthOneMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMonthOneMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMonthOneMilestone(props: HookInput<'MonthOneMilestone', { stream: false }>): HookOutput<'MonthOneMilestone', { stream: false }>
export function useMonthOneMilestone(props?: HookInput<'MonthOneMilestone', { stream?: true }>): HookOutput<'MonthOneMilestone', { stream: true }>
export function useMonthOneMilestone(
  props: HookInput<'MonthOneMilestone', { stream?: boolean }> = {},
): HookOutput<'MonthOneMilestone', { stream: true }> | HookOutput<'MonthOneMilestone', { stream: false }> {
  let action: ServerAction = Actions.MonthOneMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.MonthOneMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'MonthOneMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the MonthThreeFourMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMonthThreeFourMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMonthThreeFourMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMonthThreeFourMilestone(props: HookInput<'MonthThreeFourMilestone', { stream: false }>): HookOutput<'MonthThreeFourMilestone', { stream: false }>
export function useMonthThreeFourMilestone(props?: HookInput<'MonthThreeFourMilestone', { stream?: true }>): HookOutput<'MonthThreeFourMilestone', { stream: true }>
export function useMonthThreeFourMilestone(
  props: HookInput<'MonthThreeFourMilestone', { stream?: boolean }> = {},
): HookOutput<'MonthThreeFourMilestone', { stream: true }> | HookOutput<'MonthThreeFourMilestone', { stream: false }> {
  let action: ServerAction = Actions.MonthThreeFourMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.MonthThreeFourMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'MonthThreeFourMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the MonthTwoMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMonthTwoMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMonthTwoMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMonthTwoMilestone(props: HookInput<'MonthTwoMilestone', { stream: false }>): HookOutput<'MonthTwoMilestone', { stream: false }>
export function useMonthTwoMilestone(props?: HookInput<'MonthTwoMilestone', { stream?: true }>): HookOutput<'MonthTwoMilestone', { stream: true }>
export function useMonthTwoMilestone(
  props: HookInput<'MonthTwoMilestone', { stream?: boolean }> = {},
): HookOutput<'MonthTwoMilestone', { stream: true }> | HookOutput<'MonthTwoMilestone', { stream: false }> {
  let action: ServerAction = Actions.MonthTwoMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.MonthTwoMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'MonthTwoMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the NewbornWeekMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - week: number
 *
 * - babySex (optional): string | null
 *
 * - firstPregnancy: boolean
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - height (optional): number | null
 *
 * - headCircumference (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - activitySummary (optional): string | null
 *
 * - parentWellness (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.NewbornMilestoneOutput
 * - **Streaming Partial:** NewbornMilestoneOutput
 * - **Streaming Final:** types.NewbornMilestoneOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useNewbornWeekMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useNewbornWeekMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useNewbornWeekMilestone(props: HookInput<'NewbornWeekMilestone', { stream: false }>): HookOutput<'NewbornWeekMilestone', { stream: false }>
export function useNewbornWeekMilestone(props?: HookInput<'NewbornWeekMilestone', { stream?: true }>): HookOutput<'NewbornWeekMilestone', { stream: true }>
export function useNewbornWeekMilestone(
  props: HookInput<'NewbornWeekMilestone', { stream?: boolean }> = {},
): HookOutput<'NewbornWeekMilestone', { stream: true }> | HookOutput<'NewbornWeekMilestone', { stream: false }> {
  let action: ServerAction = Actions.NewbornWeekMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.NewbornWeekMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'NewbornWeekMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the PersonalizedTasks BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyAgeInDays: number
 *
 * - ppWeek: number
 *
 * - timeOfDay: string
 *
 * - feedingMethod: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.PersonalizedTasksOutput
 * - **Streaming Partial:** PersonalizedTasksOutput
 * - **Streaming Final:** types.PersonalizedTasksOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = usePersonalizedTasks({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = usePersonalizedTasks({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePersonalizedTasks(props: HookInput<'PersonalizedTasks', { stream: false }>): HookOutput<'PersonalizedTasks', { stream: false }>
export function usePersonalizedTasks(props?: HookInput<'PersonalizedTasks', { stream?: true }>): HookOutput<'PersonalizedTasks', { stream: true }>
export function usePersonalizedTasks(
  props: HookInput<'PersonalizedTasks', { stream?: boolean }> = {},
): HookOutput<'PersonalizedTasks', { stream: true }> | HookOutput<'PersonalizedTasks', { stream: false }> {
  let action: ServerAction = Actions.PersonalizedTasks;
  if (isStreamingProps(props)) {
    action = StreamingActions.PersonalizedTasks;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'PersonalizedTasks', { stream: false }>)
  }
}
/**
 * A specialized hook for the PlanCelebrationQuestions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - ageInDays: number
 *
 * - ageLabel: string
 *
 * - celebrationType: string
 *
 * - celebrationTitle: string
 *
 * - babyId: string
 *
 * - birthDate: string
 *
 * - gender (optional): string | null
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - activitySummary (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - medicalRecords (optional): string | null
 *
 * - parentWellness (optional): string | null
 *
 * - recentChatTopics (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.CelebrationQuestionsOutput
 * - **Streaming Partial:** CelebrationQuestionsOutput
 * - **Streaming Final:** types.CelebrationQuestionsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = usePlanCelebrationQuestions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = usePlanCelebrationQuestions({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePlanCelebrationQuestions(props: HookInput<'PlanCelebrationQuestions', { stream: false }>): HookOutput<'PlanCelebrationQuestions', { stream: false }>
export function usePlanCelebrationQuestions(props?: HookInput<'PlanCelebrationQuestions', { stream?: true }>): HookOutput<'PlanCelebrationQuestions', { stream: true }>
export function usePlanCelebrationQuestions(
  props: HookInput<'PlanCelebrationQuestions', { stream?: boolean }> = {},
): HookOutput<'PlanCelebrationQuestions', { stream: true }> | HookOutput<'PlanCelebrationQuestions', { stream: false }> {
  let action: ServerAction = Actions.PlanCelebrationQuestions;
  if (isStreamingProps(props)) {
    action = StreamingActions.PlanCelebrationQuestions;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'PlanCelebrationQuestions', { stream: false }>)
  }
}
/**
 * A specialized hook for the PostpartumTips BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.PostpartumTipsInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.PostpartumTipsOutput
 * - **Streaming Partial:** PostpartumTipsOutput
 * - **Streaming Final:** types.PostpartumTipsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = usePostpartumTips({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = usePostpartumTips({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePostpartumTips(props: HookInput<'PostpartumTips', { stream: false }>): HookOutput<'PostpartumTips', { stream: false }>
export function usePostpartumTips(props?: HookInput<'PostpartumTips', { stream?: true }>): HookOutput<'PostpartumTips', { stream: true }>
export function usePostpartumTips(
  props: HookInput<'PostpartumTips', { stream?: boolean }> = {},
): HookOutput<'PostpartumTips', { stream: true }> | HookOutput<'PostpartumTips', { stream: false }> {
  let action: ServerAction = Actions.PostpartumTips;
  if (isStreamingProps(props)) {
    action = StreamingActions.PostpartumTips;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'PostpartumTips', { stream: false }>)
  }
}
/**
 * A specialized hook for the PregnancyWeekSummary BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - week: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.PregnancyWeekSummaryOutput
 * - **Streaming Partial:** PregnancyWeekSummaryOutput
 * - **Streaming Final:** types.PregnancyWeekSummaryOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = usePregnancyWeekSummary({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = usePregnancyWeekSummary({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePregnancyWeekSummary(props: HookInput<'PregnancyWeekSummary', { stream: false }>): HookOutput<'PregnancyWeekSummary', { stream: false }>
export function usePregnancyWeekSummary(props?: HookInput<'PregnancyWeekSummary', { stream?: true }>): HookOutput<'PregnancyWeekSummary', { stream: true }>
export function usePregnancyWeekSummary(
  props: HookInput<'PregnancyWeekSummary', { stream?: boolean }> = {},
): HookOutput<'PregnancyWeekSummary', { stream: true }> | HookOutput<'PregnancyWeekSummary', { stream: false }> {
  let action: ServerAction = Actions.PregnancyWeekSummary;
  if (isStreamingProps(props)) {
    action = StreamingActions.PregnancyWeekSummary;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'PregnancyWeekSummary', { stream: false }>)
  }
}
/**
 * A specialized hook for the RoleSpecificTips BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - parentRole: string
 *
 * - ppDay (optional): number | null
 *
 * - babyAgeInDays: number
 *
 * - babyName (optional): string | null
 *
 * - babySex (optional): string | null
 *
 * - topic: string
 *
 * - recentSleepHours (optional): number | null
 *
 * - concerns (optional): string[] | null
 *
 * - recentChatTopics (optional): string | null
 *
 * - achievedMilestones (optional): string | null
 *
 * - activitySummary (optional): string | null
 *
 * - parentWellness (optional): string | null
 *
 * - medicalContext (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.RoleSpecificTipsOutput
 * - **Streaming Partial:** RoleSpecificTipsOutput
 * - **Streaming Final:** types.RoleSpecificTipsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useRoleSpecificTips({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useRoleSpecificTips({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useRoleSpecificTips(props: HookInput<'RoleSpecificTips', { stream: false }>): HookOutput<'RoleSpecificTips', { stream: false }>
export function useRoleSpecificTips(props?: HookInput<'RoleSpecificTips', { stream?: true }>): HookOutput<'RoleSpecificTips', { stream: true }>
export function useRoleSpecificTips(
  props: HookInput<'RoleSpecificTips', { stream?: boolean }> = {},
): HookOutput<'RoleSpecificTips', { stream: true }> | HookOutput<'RoleSpecificTips', { stream: false }> {
  let action: ServerAction = Actions.RoleSpecificTips;
  if (isStreamingProps(props)) {
    action = StreamingActions.RoleSpecificTips;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'RoleSpecificTips', { stream: false }>)
  }
}
/**
 * A specialized hook for the SecondWeekMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useSecondWeekMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useSecondWeekMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSecondWeekMilestone(props: HookInput<'SecondWeekMilestone', { stream: false }>): HookOutput<'SecondWeekMilestone', { stream: false }>
export function useSecondWeekMilestone(props?: HookInput<'SecondWeekMilestone', { stream?: true }>): HookOutput<'SecondWeekMilestone', { stream: true }>
export function useSecondWeekMilestone(
  props: HookInput<'SecondWeekMilestone', { stream?: boolean }> = {},
): HookOutput<'SecondWeekMilestone', { stream: true }> | HookOutput<'SecondWeekMilestone', { stream: false }> {
  let action: ServerAction = Actions.SecondWeekMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.SecondWeekMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'SecondWeekMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the SleepRegressionTips BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - babyName: string
 *
 * - week: number
 *
 * - ageInDays: number
 *
 * - currentWeightOz (optional): number | null
 *
 * - birthWeightOz (optional): number | null
 *
 * - sleepCount24h (optional): number | null
 *
 * - totalSleepHours24h (optional): number | null
 *
 * - avgSleepHoursPerDay (optional): number | null
 *
 * - feedingCount24h (optional): number | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.SleepRegressionTipsOutput
 * - **Streaming Partial:** SleepRegressionTipsOutput
 * - **Streaming Final:** types.SleepRegressionTipsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useSleepRegressionTips({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useSleepRegressionTips({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSleepRegressionTips(props: HookInput<'SleepRegressionTips', { stream: false }>): HookOutput<'SleepRegressionTips', { stream: false }>
export function useSleepRegressionTips(props?: HookInput<'SleepRegressionTips', { stream?: true }>): HookOutput<'SleepRegressionTips', { stream: true }>
export function useSleepRegressionTips(
  props: HookInput<'SleepRegressionTips', { stream?: boolean }> = {},
): HookOutput<'SleepRegressionTips', { stream: true }> | HookOutput<'SleepRegressionTips', { stream: false }> {
  let action: ServerAction = Actions.SleepRegressionTips;
  if (isStreamingProps(props)) {
    action = StreamingActions.SleepRegressionTips;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'SleepRegressionTips', { stream: false }>)
  }
}
/**
 * A specialized hook for the StalePrompts BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - topic: string
 *
 * - context: Record<string, string>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.StalePromptsOutput
 * - **Streaming Partial:** StalePromptsOutput
 * - **Streaming Final:** types.StalePromptsOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useStalePrompts({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useStalePrompts({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStalePrompts(props: HookInput<'StalePrompts', { stream: false }>): HookOutput<'StalePrompts', { stream: false }>
export function useStalePrompts(props?: HookInput<'StalePrompts', { stream?: true }>): HookOutput<'StalePrompts', { stream: true }>
export function useStalePrompts(
  props: HookInput<'StalePrompts', { stream?: boolean }> = {},
): HookOutput<'StalePrompts', { stream: true }> | HookOutput<'StalePrompts', { stream: false }> {
  let action: ServerAction = Actions.StalePrompts;
  if (isStreamingProps(props)) {
    action = StreamingActions.StalePrompts;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'StalePrompts', { stream: false }>)
  }
}
/**
 * A specialized hook for the SuggestImprovements BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - seo: string
 *
 * - accessibility: string
 *
 * - structure: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.ImprovementSuggestions
 * - **Streaming Partial:** ImprovementSuggestions
 * - **Streaming Final:** types.ImprovementSuggestions
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useSuggestImprovements({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useSuggestImprovements({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSuggestImprovements(props: HookInput<'SuggestImprovements', { stream: false }>): HookOutput<'SuggestImprovements', { stream: false }>
export function useSuggestImprovements(props?: HookInput<'SuggestImprovements', { stream?: true }>): HookOutput<'SuggestImprovements', { stream: true }>
export function useSuggestImprovements(
  props: HookInput<'SuggestImprovements', { stream?: boolean }> = {},
): HookOutput<'SuggestImprovements', { stream: true }> | HookOutput<'SuggestImprovements', { stream: false }> {
  let action: ServerAction = Actions.SuggestImprovements;
  if (isStreamingProps(props)) {
    action = StreamingActions.SuggestImprovements;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'SuggestImprovements', { stream: false }>)
  }
}
/**
 * A specialized hook for the ThirdWeekMilestone BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: types.MilestoneInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.MilestoneEnhancementOutput
 * - **Streaming Partial:** MilestoneEnhancementOutput
 * - **Streaming Final:** types.MilestoneEnhancementOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useThirdWeekMilestone({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useThirdWeekMilestone({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useThirdWeekMilestone(props: HookInput<'ThirdWeekMilestone', { stream: false }>): HookOutput<'ThirdWeekMilestone', { stream: false }>
export function useThirdWeekMilestone(props?: HookInput<'ThirdWeekMilestone', { stream?: true }>): HookOutput<'ThirdWeekMilestone', { stream: true }>
export function useThirdWeekMilestone(
  props: HookInput<'ThirdWeekMilestone', { stream?: boolean }> = {},
): HookOutput<'ThirdWeekMilestone', { stream: true }> | HookOutput<'ThirdWeekMilestone', { stream: false }> {
  let action: ServerAction = Actions.ThirdWeekMilestone;
  if (isStreamingProps(props)) {
    action = StreamingActions.ThirdWeekMilestone;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'ThirdWeekMilestone', { stream: false }>)
  }
}
/**
 * A specialized hook for the WellnessScreening BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - ppDay: number
 *
 * - ppWeek (optional): number | null
 *
 * - firstPregnancy: boolean
 *
 * - babyFirstName: string
 *
 * - ageInDays: number
 *
 * - previousCheckIns: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** types.WellnessScreeningOutput
 * - **Streaming Partial:** WellnessScreeningOutput
 * - **Streaming Final:** types.WellnessScreeningOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useWellnessScreening({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useWellnessScreening({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useWellnessScreening(props: HookInput<'WellnessScreening', { stream: false }>): HookOutput<'WellnessScreening', { stream: false }>
export function useWellnessScreening(props?: HookInput<'WellnessScreening', { stream?: true }>): HookOutput<'WellnessScreening', { stream: true }>
export function useWellnessScreening(
  props: HookInput<'WellnessScreening', { stream?: boolean }> = {},
): HookOutput<'WellnessScreening', { stream: true }> | HookOutput<'WellnessScreening', { stream: false }> {
  let action: ServerAction = Actions.WellnessScreening;
  if (isStreamingProps(props)) {
    action = StreamingActions.WellnessScreening;
    return useBamlAction(action, props)
  } else {
    return useBamlAction(action, props as HookInput<'WellnessScreening', { stream: false }>)
  }
}
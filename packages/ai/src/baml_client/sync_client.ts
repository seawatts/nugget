/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { BamlRuntime, FunctionResult, BamlCtxManager, Image, Audio, Pdf, Video, ClientRegistry, Collector, FunctionLog } from "@boundaryml/baml"
import { toBamlError, BamlAbortError, type HTTPRequest } from "@boundaryml/baml"
import type { Checked, Check, RecursivePartialNull as MovedRecursivePartialNull } from "./types"
import type * as types from "./types"
import type {AppointmentNudgeOutput, BabyAssistantChatOutput, BabyContext, BabyVisitExplainerOutput, BirthPlanHeadlineOutput, ChatMessage, ChatTitleOutput, CheckInQuestion, ContextualMilestonesOutput, DailyCheckInQuestionsOutput, HospitalPackAdviceOutput, ImprovementSuggestions, LearningTip, MilestoneEnhancementOutput, MilestoneExplanationOutput, MilestoneSuggestion, NewbornMilestoneOutput, ParentTask, ParentTip, PersonalizedTasksOutput, PostpartumTipsOutput, PregnancyWeekSummaryOutput, ResponseType, RoleSpecificTipsOutput, SleepRegressionTipsOutput, StalePromptsOutput, WellnessQuestion, WellnessScreeningOutput} from "./types"
import type TypeBuilder from "./type_builder"
import { HttpRequest, HttpStreamRequest } from "./sync_request"
import { LlmResponseParser, LlmStreamParser } from "./parser"
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"
import type * as events from "./events"

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 * Example:
 * ```ts
 * import { RecursivePartialNull } from './baml_client/types'
 * ```
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>;

type TickReason = "Unknown";

type BamlCallOptions<WatchersT = never> = {
  tb?: TypeBuilder
  clientRegistry?: ClientRegistry
  collector?: Collector | Collector[]
  env?: Record<string, string | undefined>
  tags?: Record<string, string>
  signal?: AbortSignal
  onTick?: (reason: TickReason, log: FunctionLog | null) => void
  watchers?: WatchersT
}

export class BamlSyncClient {
  private httpRequest: HttpRequest
  private httpStreamRequest: HttpStreamRequest
  private llmResponseParser: LlmResponseParser
  private llmStreamParser: LlmStreamParser
  private bamlOptions: BamlCallOptions

  constructor(private runtime: BamlRuntime, private ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
    this.httpRequest = new HttpRequest(runtime, ctxManager)
    this.httpStreamRequest = new HttpStreamRequest(runtime, ctxManager)
    this.llmResponseParser = new LlmResponseParser(runtime, ctxManager)
    this.llmStreamParser = new LlmStreamParser(runtime, ctxManager)
    this.bamlOptions = bamlOptions || {}
  }

  withOptions(bamlOptions: BamlCallOptions) {
    return new BamlSyncClient(this.runtime, this.ctxManager, bamlOptions)
  }

  /*
  * @deprecated NOT IMPLEMENTED as streaming must by async. We
  * are not providing an async version as we want to reserve the
  * right to provide a sync version in the future.
  */
  get stream() {
    throw new Error("stream is not available in BamlSyncClient. Use `import { b } from 'baml_client/async_client")
  }

  get request() {
    return this.httpRequest
  }

  get streamRequest() {
    return this.httpStreamRequest
  }

  get parse() {
    return this.llmResponseParser
  }

  get parseStream() {
    return this.llmStreamParser
  }

  
  AppointmentNudge(
      type: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.AppointmentNudgeOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "AppointmentNudge",
        {
          "type": type
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.AppointmentNudgeOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BabyAssistantChat(
      conversationHistory: types.ChatMessage[],babyContext: types.BabyContext,userQuestion: string,systemPrompt?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.BabyAssistantChatOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BabyAssistantChat",
        {
          "conversationHistory": conversationHistory,"babyContext": babyContext,"userQuestion": userQuestion,"systemPrompt": systemPrompt?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BabyAssistantChatOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BabyVisitExplainer(
      ageWeeks: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.BabyVisitExplainerOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BabyVisitExplainer",
        {
          "ageWeeks": ageWeeks
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BabyVisitExplainerOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BirthPlanHeadline(
      mode: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.BirthPlanHeadlineOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BirthPlanHeadline",
        {
          "mode": mode
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BirthPlanHeadlineOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  DailyCheckInQuestions(
      ppDay: number,parentRole: string,parentSleepHours?: number | null,ageInDays: number,ageInWeeks: number,firstPregnancy: boolean,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.DailyCheckInQuestionsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "DailyCheckInQuestions",
        {
          "ppDay": ppDay,"parentRole": parentRole,"parentSleepHours": parentSleepHours?? null,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"firstPregnancy": firstPregnancy,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.DailyCheckInQuestionsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  EnhanceMilestone(
      milestoneTitle: string,milestoneDescription: string,milestoneType: string,ageLabel: string,babyName?: string | null,ageInDays?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "EnhanceMilestone",
        {
          "milestoneTitle": milestoneTitle,"milestoneDescription": milestoneDescription,"milestoneType": milestoneType,"ageLabel": ageLabel,"babyName": babyName?? null,"ageInDays": ageInDays?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateChatTitle(
      firstUserMessage: string,firstAssistantResponse: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.ChatTitleOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateChatTitle",
        {
          "firstUserMessage": firstUserMessage,"firstAssistantResponse": firstAssistantResponse
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ChatTitleOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateContextualMilestones(
      babyName: string,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,diaperCount24h?: number | null,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,recentDiaperColors?: string | null,hasTummyTimeActivity?: boolean | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.ContextualMilestonesOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateContextualMilestones",
        {
          "babyName": babyName,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null,"recentDiaperColors": recentDiaperColors?? null,"hasTummyTimeActivity": hasTummyTimeActivity?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ContextualMilestonesOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  HospitalPackAdvice(
      progress: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.HospitalPackAdviceOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "HospitalPackAdvice",
        {
          "progress": progress
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.HospitalPackAdviceOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MilestoneExplanation(
      milestoneTitle: string,milestoneType: string,babyName: string,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneExplanationOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MilestoneExplanation",
        {
          "milestoneTitle": milestoneTitle,"milestoneType": milestoneType,"babyName": babyName,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneExplanationOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  NewbornWeekMilestone(
      babyName: string,week: number,babySex?: string | null,firstPregnancy: boolean,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,headCircumference?: number | null,feedingCount24h?: number | null,sleepCount24h?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.NewbornMilestoneOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "NewbornWeekMilestone",
        {
          "babyName": babyName,"week": week,"babySex": babySex?? null,"firstPregnancy": firstPregnancy,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"headCircumference": headCircumference?? null,"feedingCount24h": feedingCount24h?? null,"sleepCount24h": sleepCount24h?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.NewbornMilestoneOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PersonalizedTasks(
      babyAgeInDays: number,ppWeek: number,timeOfDay: string,feedingMethod: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.PersonalizedTasksOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PersonalizedTasks",
        {
          "babyAgeInDays": babyAgeInDays,"ppWeek": ppWeek,"timeOfDay": timeOfDay,"feedingMethod": feedingMethod
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PersonalizedTasksOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PostpartumTips(
      babyName: string,day: number,firstPregnancy: boolean,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,headCircumference?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,diaperCount24h?: number | null,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.PostpartumTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PostpartumTips",
        {
          "babyName": babyName,"day": day,"firstPregnancy": firstPregnancy,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"headCircumference": headCircumference?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PostpartumTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PregnancyWeekSummary(
      week: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.PregnancyWeekSummaryOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PregnancyWeekSummary",
        {
          "week": week
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PregnancyWeekSummaryOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  RoleSpecificTips(
      parentRole: string,ppDay?: number | null,babyAgeInDays: number,topic: string,recentSleepHours?: number | null,concerns?: string[] | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.RoleSpecificTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "RoleSpecificTips",
        {
          "parentRole": parentRole,"ppDay": ppDay?? null,"babyAgeInDays": babyAgeInDays,"topic": topic,"recentSleepHours": recentSleepHours?? null,"concerns": concerns?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.RoleSpecificTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  SleepRegressionTips(
      babyName: string,week: number,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,avgSleepHoursPerDay?: number | null,feedingCount24h?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.SleepRegressionTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "SleepRegressionTips",
        {
          "babyName": babyName,"week": week,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"feedingCount24h": feedingCount24h?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.SleepRegressionTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  StalePrompts(
      topic: string,context: Record<string, string>,
      __baml_options__?: BamlCallOptions<never>
  ): types.StalePromptsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "StalePrompts",
        {
          "topic": topic,"context": context
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.StalePromptsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  SuggestImprovements(
      seo: string,accessibility: string,structure: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.ImprovementSuggestions {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "SuggestImprovements",
        {
          "seo": seo,"accessibility": accessibility,"structure": structure
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ImprovementSuggestions
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  WellnessScreening(
      ppDay: number,ppWeek?: number | null,firstPregnancy: boolean,babyFirstName: string,ageInDays: number,previousCheckIns: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.WellnessScreeningOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "WellnessScreening",
        {
          "ppDay": ppDay,"ppWeek": ppWeek?? null,"firstPregnancy": firstPregnancy,"babyFirstName": babyFirstName,"ageInDays": ageInDays,"previousCheckIns": previousCheckIns
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.WellnessScreeningOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
}

export const b = new BamlSyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)
/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { BamlRuntime, FunctionResult, BamlCtxManager, Image, Audio, Pdf, Video, ClientRegistry, Collector, FunctionLog } from "@boundaryml/baml"
import { toBamlError, BamlAbortError, type HTTPRequest } from "@boundaryml/baml"
import type { Checked, Check, RecursivePartialNull as MovedRecursivePartialNull } from "./types"
import type * as types from "./types"
import type {AppointmentNudgeOutput, BabyAssistantChatOutput, BabyContext, BabyVisitExplainerOutput, BirthPlanHeadlineOutput, CelebrationQuestion, CelebrationQuestionsOutput, CelebrationStatistics, CelebrationSummaryOutput, ChatMessage, ChatTitleOutput, CheckInQuestion, ContextualMilestonesOutput, DailyCheckInQuestionsOutput, DailyLearningPlan, DailyWellnessQuestionOutput, DoctorQuestionsOutput, HospitalPackAdviceOutput, ImprovementSuggestions, LearningPlanItem, LearningTip, MilestoneEnhancementOutput, MilestoneExplanationOutput, MilestoneInput, MilestonePlan, MilestonePlanItem, MilestoneSuggestion, NewbornMilestoneOutput, ParentTask, ParentTip, PersonalizedTasksOutput, PostpartumTipsInput, PostpartumTipsOutput, PregnancyWeekSummaryOutput, ResponseType, RoleSpecificTipsOutput, SleepRegressionTipsOutput, StalePromptsOutput, WellnessQuestion, WellnessScreeningOutput} from "./types"
import type TypeBuilder from "./type_builder"
import { HttpRequest, HttpStreamRequest } from "./sync_request"
import { LlmResponseParser, LlmStreamParser } from "./parser"
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"
import type * as events from "./events"

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 * Example:
 * ```ts
 * import { RecursivePartialNull } from './baml_client/types'
 * ```
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>;

type TickReason = "Unknown";

type BamlCallOptions<WatchersT = never> = {
  tb?: TypeBuilder
  clientRegistry?: ClientRegistry
  collector?: Collector | Collector[]
  env?: Record<string, string | undefined>
  tags?: Record<string, string>
  signal?: AbortSignal
  onTick?: (reason: TickReason, log: FunctionLog | null) => void
  watchers?: WatchersT
}

export class BamlSyncClient {
  private httpRequest: HttpRequest
  private httpStreamRequest: HttpStreamRequest
  private llmResponseParser: LlmResponseParser
  private llmStreamParser: LlmStreamParser
  private bamlOptions: BamlCallOptions

  constructor(private runtime: BamlRuntime, private ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
    this.httpRequest = new HttpRequest(runtime, ctxManager)
    this.httpStreamRequest = new HttpStreamRequest(runtime, ctxManager)
    this.llmResponseParser = new LlmResponseParser(runtime, ctxManager)
    this.llmStreamParser = new LlmStreamParser(runtime, ctxManager)
    this.bamlOptions = bamlOptions || {}
  }

  withOptions(bamlOptions: BamlCallOptions) {
    return new BamlSyncClient(this.runtime, this.ctxManager, bamlOptions)
  }

  /*
  * @deprecated NOT IMPLEMENTED as streaming must by async. We
  * are not providing an async version as we want to reserve the
  * right to provide a sync version in the future.
  */
  get stream() {
    throw new Error("stream is not available in BamlSyncClient. Use `import { b } from 'baml_client/async_client")
  }

  get request() {
    return this.httpRequest
  }

  get streamRequest() {
    return this.httpStreamRequest
  }

  get parse() {
    return this.llmResponseParser
  }

  get parseStream() {
    return this.llmStreamParser
  }

  
  AppointmentNudge(
      type: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.AppointmentNudgeOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "AppointmentNudge",
        {
          "type": type
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.AppointmentNudgeOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BabyAssistantChat(
      conversationHistory: types.ChatMessage[],babyContext: types.BabyContext,userQuestion: string,systemPrompt?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.BabyAssistantChatOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BabyAssistantChat",
        {
          "conversationHistory": conversationHistory,"babyContext": babyContext,"userQuestion": userQuestion,"systemPrompt": systemPrompt?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BabyAssistantChatOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BabyVisitExplainer(
      ageWeeks: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.BabyVisitExplainerOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BabyVisitExplainer",
        {
          "ageWeeks": ageWeeks
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BabyVisitExplainerOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  BirthPlanHeadline(
      mode: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.BirthPlanHeadlineOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "BirthPlanHeadline",
        {
          "mode": mode
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.BirthPlanHeadlineOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  DailyCheckInQuestions(
      ppDay: number,parentRole: string,parentSleepHours?: number | null,ageInDays: number,ageInWeeks: number,firstPregnancy: boolean,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.DailyCheckInQuestionsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "DailyCheckInQuestions",
        {
          "ppDay": ppDay,"parentRole": parentRole,"parentSleepHours": parentSleepHours?? null,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"firstPregnancy": firstPregnancy,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.DailyCheckInQuestionsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  DailyLearningPlanner(
      babyName: string,babySex?: string | null,ageInDays: number,ageInWeeks: number,firstTimeParent: boolean,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,diaperCount24h?: number | null,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,recentChatTopics?: string | null,recentlyCoveredTopics?: string | null,achievedMilestones?: string | null,activitySummary?: string | null,parentWellness?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.DailyLearningPlan {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "DailyLearningPlanner",
        {
          "babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"firstTimeParent": firstTimeParent,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null,"recentChatTopics": recentChatTopics?? null,"recentlyCoveredTopics": recentlyCoveredTopics?? null,"achievedMilestones": achievedMilestones?? null,"activitySummary": activitySummary?? null,"parentWellness": parentWellness?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.DailyLearningPlan
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  DailyWellnessQuestion(
      babyName: string,babyAgeInDays: number,babyAgeInWeeks: number,feedingCount24h?: number | null,sleepHours24h?: number | null,diaperCount24h?: number | null,previousResponses?: string | null,currentStreak?: number | null,weeklyCompletionCount?: number | null,daysSinceLastResponse?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.DailyWellnessQuestionOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "DailyWellnessQuestion",
        {
          "babyName": babyName,"babyAgeInDays": babyAgeInDays,"babyAgeInWeeks": babyAgeInWeeks,"feedingCount24h": feedingCount24h?? null,"sleepHours24h": sleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"previousResponses": previousResponses?? null,"currentStreak": currentStreak?? null,"weeklyCompletionCount": weeklyCompletionCount?? null,"daysSinceLastResponse": daysSinceLastResponse?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.DailyWellnessQuestionOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  EnhanceMilestone(
      milestoneTitle: string,milestoneDescription: string,milestoneType: string,ageLabel: string,babyName?: string | null,babySex?: string | null,ageInDays?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,activitySummary?: string | null,parentWellness?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "EnhanceMilestone",
        {
          "milestoneTitle": milestoneTitle,"milestoneDescription": milestoneDescription,"milestoneType": milestoneType,"ageLabel": ageLabel,"babyName": babyName?? null,"babySex": babySex?? null,"ageInDays": ageInDays?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"activitySummary": activitySummary?? null,"parentWellness": parentWellness?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  FirstWeekMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "FirstWeekMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateCelebrationSummary(
      babyName: string,ageInDays: number,celebrationType: string,celebrationTitle: string,statistics: types.CelebrationStatistics,recentMilestones?: string | null,recentActivities?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.CelebrationSummaryOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateCelebrationSummary",
        {
          "babyName": babyName,"ageInDays": ageInDays,"celebrationType": celebrationType,"celebrationTitle": celebrationTitle,"statistics": statistics,"recentMilestones": recentMilestones?? null,"recentActivities": recentActivities?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.CelebrationSummaryOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateChatTitle(
      firstUserMessage: string,firstAssistantResponse: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.ChatTitleOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateChatTitle",
        {
          "firstUserMessage": firstUserMessage,"firstAssistantResponse": firstAssistantResponse
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ChatTitleOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateContextualMilestones(
      babyName: string,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,diaperCount24h?: number | null,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,recentDiaperColors?: string | null,hasTummyTimeActivity?: boolean | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.ContextualMilestonesOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateContextualMilestones",
        {
          "babyName": babyName,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null,"recentDiaperColors": recentDiaperColors?? null,"hasTummyTimeActivity": hasTummyTimeActivity?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ContextualMilestonesOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateDoctorQuestions(
      babyName: string,babySex?: string | null,ageInDays: number,dayCount: number,totalFeedings: number,averageFeedingsPerDay: number,totalFeedingMl: number,averageMlPerFeeding: number,totalSleeps: number,totalSleepHours: number,averageSleepHoursPerDay: number,longestSleepHours: number,totalDiapers: number,averageDiapersPerDay: number,wetDiapers: number,dirtyDiapers: number,bothDiapers: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.DoctorQuestionsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateDoctorQuestions",
        {
          "babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"dayCount": dayCount,"totalFeedings": totalFeedings,"averageFeedingsPerDay": averageFeedingsPerDay,"totalFeedingMl": totalFeedingMl,"averageMlPerFeeding": averageMlPerFeeding,"totalSleeps": totalSleeps,"totalSleepHours": totalSleepHours,"averageSleepHoursPerDay": averageSleepHoursPerDay,"longestSleepHours": longestSleepHours,"totalDiapers": totalDiapers,"averageDiapersPerDay": averageDiapersPerDay,"wetDiapers": wetDiapers,"dirtyDiapers": dirtyDiapers,"bothDiapers": bothDiapers
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.DoctorQuestionsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_FirstWeek(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_FirstWeek",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_ImmediatePostbirth(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_ImmediatePostbirth",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_MonthOne(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_MonthOne",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_MonthThreeFour(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_MonthThreeFour",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_MonthTwo(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_MonthTwo",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_SecondWeek(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_SecondWeek",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  GenerateLearningTip_ThirdWeek(
      category: string,title: string,subtitle: string,relevance: string,recommendYesNo: boolean,babyName: string,babySex?: string | null,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.LearningTip {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "GenerateLearningTip_ThirdWeek",
        {
          "category": category,"title": title,"subtitle": subtitle,"relevance": relevance,"recommendYesNo": recommendYesNo,"babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.LearningTip
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  HospitalPackAdvice(
      progress: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.HospitalPackAdviceOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "HospitalPackAdvice",
        {
          "progress": progress
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.HospitalPackAdviceOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  ImmediatePostbirthMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "ImmediatePostbirthMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MilestoneExplanation(
      milestoneTitle: string,milestoneType: string,babyName: string,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,feedingCount24h?: number | null,sleepCount24h?: number | null,diaperCount24h?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneExplanationOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MilestoneExplanation",
        {
          "milestoneTitle": milestoneTitle,"milestoneType": milestoneType,"babyName": babyName,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"feedingCount24h": feedingCount24h?? null,"sleepCount24h": sleepCount24h?? null,"diaperCount24h": diaperCount24h?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneExplanationOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MilestonePlanner(
      babyName: string,babySex?: string | null,ageInDays: number,ageInWeeks: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,feedingCount24h?: number | null,avgFeedingInterval?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,diaperCount24h?: number | null,avgFeedingsPerDay?: number | null,avgSleepHoursPerDay?: number | null,avgDiaperChangesPerDay?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,recentlySuggestedMilestones?: string | null,activitySummary?: string | null,hasTummyTimeActivity?: boolean | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestonePlan {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MilestonePlanner",
        {
          "babyName": babyName,"babySex": babySex?? null,"ageInDays": ageInDays,"ageInWeeks": ageInWeeks,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"feedingCount24h": feedingCount24h?? null,"avgFeedingInterval": avgFeedingInterval?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"diaperCount24h": diaperCount24h?? null,"avgFeedingsPerDay": avgFeedingsPerDay?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"avgDiaperChangesPerDay": avgDiaperChangesPerDay?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"recentlySuggestedMilestones": recentlySuggestedMilestones?? null,"activitySummary": activitySummary?? null,"hasTummyTimeActivity": hasTummyTimeActivity?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestonePlan
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MonthOneMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MonthOneMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MonthThreeFourMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MonthThreeFourMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  MonthTwoMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "MonthTwoMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  NewbornWeekMilestone(
      babyName: string,week: number,babySex?: string | null,firstPregnancy: boolean,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,height?: number | null,headCircumference?: number | null,feedingCount24h?: number | null,sleepCount24h?: number | null,recentChatTopics?: string | null,achievedMilestones?: string | null,activitySummary?: string | null,parentWellness?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.NewbornMilestoneOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "NewbornWeekMilestone",
        {
          "babyName": babyName,"week": week,"babySex": babySex?? null,"firstPregnancy": firstPregnancy,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"height": height?? null,"headCircumference": headCircumference?? null,"feedingCount24h": feedingCount24h?? null,"sleepCount24h": sleepCount24h?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"activitySummary": activitySummary?? null,"parentWellness": parentWellness?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.NewbornMilestoneOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PersonalizedTasks(
      babyAgeInDays: number,ppWeek: number,timeOfDay: string,feedingMethod: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.PersonalizedTasksOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PersonalizedTasks",
        {
          "babyAgeInDays": babyAgeInDays,"ppWeek": ppWeek,"timeOfDay": timeOfDay,"feedingMethod": feedingMethod
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PersonalizedTasksOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PlanCelebrationQuestions(
      babyName: string,ageInDays: number,ageLabel: string,celebrationType: string,celebrationTitle: string,babyId: string,birthDate: string,gender?: string | null,currentWeightOz?: number | null,birthWeightOz?: number | null,activitySummary?: string | null,achievedMilestones?: string | null,medicalRecords?: string | null,parentWellness?: string | null,recentChatTopics?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.CelebrationQuestionsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PlanCelebrationQuestions",
        {
          "babyName": babyName,"ageInDays": ageInDays,"ageLabel": ageLabel,"celebrationType": celebrationType,"celebrationTitle": celebrationTitle,"babyId": babyId,"birthDate": birthDate,"gender": gender?? null,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"activitySummary": activitySummary?? null,"achievedMilestones": achievedMilestones?? null,"medicalRecords": medicalRecords?? null,"parentWellness": parentWellness?? null,"recentChatTopics": recentChatTopics?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.CelebrationQuestionsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PostpartumTips(
      input: types.PostpartumTipsInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.PostpartumTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PostpartumTips",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PostpartumTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  PregnancyWeekSummary(
      week: number,
      __baml_options__?: BamlCallOptions<never>
  ): types.PregnancyWeekSummaryOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "PregnancyWeekSummary",
        {
          "week": week
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.PregnancyWeekSummaryOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  RoleSpecificTips(
      parentRole: string,ppDay?: number | null,babyAgeInDays: number,babyName?: string | null,babySex?: string | null,topic: string,recentSleepHours?: number | null,concerns?: string[] | null,recentChatTopics?: string | null,achievedMilestones?: string | null,activitySummary?: string | null,parentWellness?: string | null,medicalContext?: string | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.RoleSpecificTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "RoleSpecificTips",
        {
          "parentRole": parentRole,"ppDay": ppDay?? null,"babyAgeInDays": babyAgeInDays,"babyName": babyName?? null,"babySex": babySex?? null,"topic": topic,"recentSleepHours": recentSleepHours?? null,"concerns": concerns?? null,"recentChatTopics": recentChatTopics?? null,"achievedMilestones": achievedMilestones?? null,"activitySummary": activitySummary?? null,"parentWellness": parentWellness?? null,"medicalContext": medicalContext?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.RoleSpecificTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  SecondWeekMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "SecondWeekMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  SleepRegressionTips(
      babyName: string,week: number,ageInDays: number,currentWeightOz?: number | null,birthWeightOz?: number | null,sleepCount24h?: number | null,totalSleepHours24h?: number | null,avgSleepHoursPerDay?: number | null,feedingCount24h?: number | null,
      __baml_options__?: BamlCallOptions<never>
  ): types.SleepRegressionTipsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "SleepRegressionTips",
        {
          "babyName": babyName,"week": week,"ageInDays": ageInDays,"currentWeightOz": currentWeightOz?? null,"birthWeightOz": birthWeightOz?? null,"sleepCount24h": sleepCount24h?? null,"totalSleepHours24h": totalSleepHours24h?? null,"avgSleepHoursPerDay": avgSleepHoursPerDay?? null,"feedingCount24h": feedingCount24h?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.SleepRegressionTipsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  StalePrompts(
      topic: string,context: Record<string, string>,
      __baml_options__?: BamlCallOptions<never>
  ): types.StalePromptsOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "StalePrompts",
        {
          "topic": topic,"context": context
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.StalePromptsOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  SuggestImprovements(
      seo: string,accessibility: string,structure: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.ImprovementSuggestions {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "SuggestImprovements",
        {
          "seo": seo,"accessibility": accessibility,"structure": structure
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.ImprovementSuggestions
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  ThirdWeekMilestone(
      input: types.MilestoneInput,
      __baml_options__?: BamlCallOptions<never>
  ): types.MilestoneEnhancementOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "ThirdWeekMilestone",
        {
          "input": input
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.MilestoneEnhancementOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
  WellnessScreening(
      ppDay: number,ppWeek?: number | null,firstPregnancy: boolean,babyFirstName: string,ageInDays: number,previousCheckIns: string,
      __baml_options__?: BamlCallOptions<never>
  ): types.WellnessScreeningOutput {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;

      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }

      // Check if onTick is provided and reject for sync operations
      if (options.onTick) {
        throw new Error("onTick is not supported for synchronous functions. Please use the async client instead.");
      }

      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.callFunctionSync(
        "WellnessScreening",
        {
          "ppDay": ppDay,"ppWeek": ppWeek?? null,"firstPregnancy": firstPregnancy,"babyFirstName": babyFirstName,"ageInDays": ageInDays,"previousCheckIns": previousCheckIns
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        options.tags || {},
        env,
        signal,
        options.watchers,
      )
      return raw.parsed(false) as types.WellnessScreeningOutput
    } catch (error: any) {
      throw toBamlError(error);
    }
  }
  
}

export const b = new BamlSyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)